// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
package tiger;

import com.google.auto.service.AutoService;
import com.google.common.collect.Collections2;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import dagger.Module;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.inject.Inject;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic.Kind;

/**
 * Collects Dagger Component interfaces and generate Dagger Component implementions by wraping about
 * tiger injectors.
 */
@AutoService(Processor.class)
public class ProxyProcessor extends AbstractProcessor {
  private static final String TAG = "ProxyProcessor";
  private static final String COMPONANT_ANNOTATION_ELEMENT_DEPENDENCIES = "dependencies";
  private static final String MODULE_ANNOTATION_ELEMENT_SUBCOMPONENTS = "subcomponents";

  private String coreInjectorPackage;
  private Elements elements;
  private Types types;
  private Messager messager;

  private Map<TypeElement, TypeElement> componentToParentMap = new HashMap<>();
  private ScopeAliasCondenser scopeAliasCondenser;
  private Map<CoreInjectorInfo, CoreInjectorInfo> coreInjectorTree;
  private CoreInjectorInfo rootCoreInjectorInfo;
  private ScopeSizer scopeSizer;
  private SetMultimap<CoreInjectorInfo, TypeElement> scopedModules = HashMultimap.create();
  private Set<TypeElement> unscopedModules = new HashSet<>();
  private SetMultimap<CoreInjectorInfo, TypeElement> scopedPassedModules = HashMultimap.create();
  private Set<TypeElement> unscopedPassedModules = new HashSet<>();
  private Map<TypeElement, TypeElement> componentToBuilderMap = new HashMap<>();

  private Collection<DependencyInfo> dependencyInfos;
  private SetMultimap<BindingKey, DependencyInfo> dependencies;

  private Map<TypeElement, CoreInjectorInfo> componentToCoreInjectorMap;

  private List<String> allRecoverableErrors = new ArrayList<>();

  private Tiger2InjectorGenerator tiger2InjectorGenerator;
  private RoundEnvironment roundEnvironment;
  private SetMultimap<CoreInjectorInfo, TypeElement> coreInjectorToBothComponentBuilderMap =
      HashMultimap.create();
  private SetMultimap<TypeElement, TypeElement> componentToComponentDependencyMap;
  private SetMultimap<CoreInjectorInfo, TypeElement> coreInjectorToComponentDependencyMap;
  private SetMultimap<TypeElement, BindingKey> componentToBindsInstanceMap;
  private SetMultimap<CoreInjectorInfo, BindingKey> coreInjectorToBindsInstanceMap;
  private Set<TypeElement> components = new HashSet<>();
  private Set<TypeElement> componentBuilders;
  private SetMultimap<TypeElement, DependencyInfo> componentToBindingsFromDependenciesMap;
  private String topLevelInjectorPrefix = "Tiger";
  private String topLevelInjectorSuffix = "Injector";

  // This need to survive processing rounds so that (sub)components failed for recoverable error can
  // be completed in later round(s).
  private Set<TypeElement> doneEitherComponents = new HashSet<>();
  private Set<TypeElement> allModules = new HashSet<>();
  private Set<Element> allInjected = new HashSet<>();
  private boolean done;
  private Utils utils;

  @Override
  public synchronized void init(ProcessingEnvironment env) {
    super.init(env);

    elements = env.getElementUtils();
    types = env.getTypeUtils();
    messager = env.getMessager();
  }

  /**
   * Because this processor needs output of the @ContributesAndroidInjector, if it cannot find the
   * subcomponents generated by that processor, it will just skip. But before that it needs to
   * collect all the (sub)components and their builders. {@link
   * RoundEnvironment#getElementsAnnotatedWith(TypeElement)} can only get the element in its round.
   *
   * <p>TODO: currently, the will be executed for each library that contributes into the app. That
   * fine because all the Subcompoments is depended by their parent (sub)component therefore we will
   * get the full graph when building the lib with the parent component. In case of component, the
   * process is reversed. They depends on their parent if any. There could be multiple libs with
   * child components that depend on a parent component in another lib. In such case, no build
   * target will have a full graph. And the parent component will be generated many times. But
   * that's fine because all of them are identical. Doesn't matter which one is instantiated. And
   * java can have multiple definition of same class in its class path.
   */
  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
    messager.printMessage(Kind.NOTE, String.format("%s: process() ", TAG));
    this.roundEnvironment = env;
    utils = new Utils(processingEnv, roundEnvironment);
    // TODO: revisit this for package java/com/google/android/apps/gmm/base/views/asyncimageview
    if (done) {
      return false;
    }

    Set<TypeElement> newModules = utils.getTypedElements(env, Module.class);
    allModules.addAll(newModules);
    Set<Element> newClasses = utils.getTypedElements(env, Inject.class);
    allInjected.addAll(newClasses);
    if (newModules.isEmpty() && newClasses.isEmpty()) {
      return false;
    }
    // messager.printMessage(
    //     Kind.NOTE, TAG + ".process: modules " + allModules + "injected classes: " + allInjected);

    Set<TypeElement> classesWithInject =
        Sets.newHashSet(
            Collections2.transform(
                allInjected,
                e -> {
                  // messager.printMessage(Kind.NOTE, TAG + ".process: " + e);
                  return (TypeElement) e.getEnclosingElement();
                }));
    // messager.printMessage(
    //     Kind.NOTE, TAG + ".process: ctor injected classes " + classesWithInject);

    done = true;
    new ProxyGenerator(processingEnv, utils).generate(allModules, classesWithInject);

    return false;
  }

  @Override
  public Set<String> getSupportedAnnotationTypes() {
    return Sets.newHashSet(Module.class.getCanonicalName(), Inject.class.getCanonicalName());
  }

  @Override
  public SourceVersion getSupportedSourceVersion() {
    return SourceVersion.latestSupported();
  }
}
